* swipl to start prolog and halt. to end it
* Prolog is built on the basis of knowledge basis and queries
* characteriscs are given to object such as the object is the parameter
  in a function call of the characteristic
  ex: happy(jake)
* rules are in the form state:- condition, read state is true given condition
  or it can be said that :- means implied by 
  ex: happy(jake):- programming(jake)
* the part on the left side of the rule is called the head of the rule and 
  the part on the right side is called the body, so it is said that if the 
  body of the rule is true then the head of the rule is true
* The fundamental deduction of a head given a body is called modus ponens
* The facts and rules contained in a knowledge base are called clauses, 
  meaning that a fact is a clause and a rule is a clause
* Each characteristic is a predicate, this can be thought of as a 
  characteristic of an object is a predicate function's perception
  of the object
* Each clause containing a predicate is said to be defining the 
  predicate
* A fact is a rule with an empty body
* An implication in a rule is called a goal, and a rule can have many goals
** To load a knowledge base: consult('knowledge_base_file.pl'). <-- notice the full stop, this
      is much like the semi-colon in other languages
  * also [knowlege_base_file] works too 
* logical conjuction (and and statement) can be simplified in prolog with the use of a comma.
  ex:   playsAirGuitar(vincent):- 
            listens2Music(vincent), 
            happy(vincent). 
* logical disjunction (an or statement) can be simplified in prolog by the use of a semicolon.
  ex: playsAirGuitar(butch):-                                       playsAirGuitar(butch):- 
         happy(butch).                 can be simplified to        happy(butch);   <-- with the semicolon idicating or 
   playsAirGuitar(butch):-                                               listens2Music(butch).
         listens2Music(butch).                                           
* any word beginning with an upper-case letter is a Prolog variable, so constants should be lower cased
* In KB4 we can query woman(X), it will show mia, then if we provide a ; it will tell us more about
  individuals that the predicate to woman is true for
* If we provide a full stop at the prompt, the rwie will begin again
* loves(marsellus,X),  woman(X). is a more complicated query that can determine if there exists X such that
  X is loved by marsellus and X is a woman
*  recursive term structure and variable unification is the source of much of Prolog’s power.
* to see the knowledge base that the current prolog session has: listing.
* listing(predicate) will return all individuals that meet the condition of playingAirGuitar
* Prolog will unify, but also what it will do to the variables to achieve this.
1) If term1 and term2 are constants, then term1 and term2 unify if and only if they are the same atom, or the same number.
2) If term1 is a variable and term2 is any type of term, then term1 and term2 unify, and term1 is instantiated to term2 . Similarly, if term2 is a variable and term1 is any type of term, then term1 and term2 unify, and term2 is instantiated to term1 . (So if they are both variables, they’re both instantiated to each other, and we say that they share values.)
3) If term1 and term2 are complex terms, then they unify if and only if:
        They have the same functor and arity, and
        all their corresponding arguments unify, and
        the variable instantiations are compatible. (For example, it is not possible to instantiate variable X to mia when unifying one pair of arguments, and to instantiate   X to vincent when unifying another pair of arguments .)
4) Two terms unify if and only if it follows from the previous three clauses that they unify.
*  ’mia’ and mia are the same atom
* occurs check: This means that if it is asked to unify a variable with a term
  ex: X = father(X)
* Pessimism is safe, but optimism is a lot faster!
* unify_with_occurs_check(father(X),X). will do an occurs check before unification
* g else in the knowledge base that unifies with g(a) , but there is another way of unifying f(_G34) . Points in the search where there are several alternative ways of unifying a goal against the knowledge base are called choice points. Prolog keeps track of choice points it has encountered, so that if it makes a wrong choice it can retreat to the previous choice point and try something else instead. This process is called backtracking, and it is fundamental to proof search in Prolog.
* \= is the negation of =
* with the use of assert and retract you can dynamically declare and retract rules
*  Building and binding. Recursion, unification, and proof search. These are ideas that lie at the heart of Prolog programming. Whenever we have to generate or analyse recursively structured objects (such as these numerals) the interplay of these ideas makes Prolog a powerful tool
* Roughly speaking (we’ll add a caveat later on) changing the order of rules in a Prolog program does not change (up to the order in which solutions are found) the program’s behaviour
* a left recursive rule, that is, a rule where the leftmost item of the body is identical (modulo the choice of variables) with the rule’s head. As our example shows, such rules easily give rise to non-terminating computations. Goal order, and in particular left recursion, is the root of all evil when it comes to non-termination.
*  when it comes to non-terminating programs, rule ordering changes can lead to some extra solutions being found.
* When writing a prolog program it is good to think declaratively, then once the world is modelled correctly it is good to think
    procedurally to see how queries will interact with the world
* trace() notrace() nodebug()
* Prolog has a special built-in operator | which can be used to decompose a list into its head and tail ( or car and cdr )
  ex: [Head|Tail]  =  [mia,  vincent,  jules,  yolanda]. ( use with unification )
         [X,Y  |  W]  =  [[],  dead(z),  [2,  [b,  c]],  [],  Z].  ( can extract multiple elements, | kinda works like rest )
* member will determine if an element is an elemnt of a list
     ex: member(jake,[jake, annie])
          member(X,[yolanda,trudy,vincent,jules]).  ( will give us all of the elements of the list)
* Arithmetic is done as the following 
      ex: X is 7 + 2 , ( prolog answers X = 9 )
            X is mod(7.2)
* this is really computing  is(X,+(3,2))
* Arithmetic examples	Prolog Notation
x < y	X  <  Y.
x ≤ y	X  =<  Y.
x = y	X  =:=  Y.
x ⁄ = y	X  =\=  Y.
x ≥ y	X  >=  Y
x > y	X  >  Y
* these expressions force their operators to be evalutated
* The key idea underlying difference lists is to represent the information about grammatical categories not as a single list, but as the difference between two lists
